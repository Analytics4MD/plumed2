// This document is formatted for Doxygen
/**

\page AddingAnAnalysis Implementing analysis methods in PLUMED

Implementing methods for analysing trajectory data is more complex than implementing collective variables.
Consequently it is difficult to write a step by step guide like those we have written on implementing \ref AddingAColvar "colvars" or
\ref AddingAFunction "functions".  Hence, this document tries to explain the things that we have considered and the way these 
have been incorporated into the PLMD::analysis::Analysis and PLMD::analysis::AnalysisWithLandmarks abstract base classes.  Hopefully this will provide some
insight into our rationale in writing these parts of the code and will help you to understand how any new analysis method can be 
implemented in the PLUMED code in a way that exploits those features that are already there.

\section overview An overview of analysis methods in PLUMED

There are two distinct ways in which one may wish to perform some form of analysis on a molecular dynamics trajectory.  In the first method some quantity
is calculated for each of the atoms in the trajectory in each of the frames and this is then averaged over the whole trajectory.  Velocity 
autocorrelation functions or mean squared displacements are examples of forms of analysis of this type.   The methods implemented in PLMD::analysis are 
not of this type.  These methods are designed to collect set of snapshots of the trajectory and to perform some analysis of these snapshots.
These trajectory snapshots might be the values of a particular set of collective variables for each of the frames, they might be the 
instantaneous positions of the atoms in each frame or they might be some combination of the above.  The assumption then when running one of these
analysis methods is that a representation (or snapshot) will be collected intermittently from the trajectory and then once a sufficiently large
 collection of these snapshots are collected they will be analysed. 

\section antraj Analysis on the fly

It is important to remember that PLUMED is primarily a code for performing biased molecular dynamics.  The code's original purpose was
to be a plugin that could be easily added to a number of different molecular dynamics engines that allowed additional forces to be 
incorporated when integrating the equations of motion.  The command line tools that allows one to analyse trajectories during post
processing were added later as an afterthought.  This consideration is particularly important when considering analysis algorithms 
in this code because most analysis algorithms that are used in the community read in the trajectory and to do all their calculations 
during post processing.  The analysis algorithms that have been implemented in PLUMED can be used to post-process trajectories - you
simply make use of the command line tool driver - however, they can also be used to analyse trajectories on the fly.  We believe this 
is useful for a number of reasons:

- Computers are becoming more powerful so it is possible to run simulations for much longer.  At the same time, however, hard drives
space is at a premium and it is thus difficult to store these large trajectories for post-processing.  If trajectories can be analysed
on the fly this presents less of a problem.
- A number of free energy methods (e.g. Gaussian mixture umbrella sampling, adaptive umbrella sampling and reconnaissance metadynamics)
work by performing a sophistacated analysis of the trajectory and then using the result from this analysis to design a bias for the 
dynamics. 
- Analysis methods implemented in PLUMED can take advantage of the many different collective variables that we have implemented in 
this code and are thus extremely flexible implementations of these techniques.
- Analysis methods implemented in PLUMED make use of the PLUMED input syntax, which hopefully allows users already familiar with 
PLUMED to get to grips with using these tools more rapidly. 

As discussed in the previous section the methods in PLMD::analysis all work by storing a snapshot of the trajectory every \f$N\f$ steps
and by then running an analysis method every \f$M\f$ steps, where \f$M\f$ is some substantial multiple of \f$N\f$.  This intermittent 
storing of trajectory frames and occasional analysis of the trajectory is all looked after within the PLMD::analysis::Analysis abstract base 
class.  Any class inheriting from this base class must have a method within it named performAnalysis(), which will actually perform 
the analysis on the stored trajectory frames.  When implementing a new analysis method the majority of your development time will 
probably be spent implementing some part of this performAnalysis method.

The fact that PLMD::analysis::Analysis can be used to run trajectory analysis in either post processing or on the fly during a trajectory means
that this class must also look after a number of things.  For example one might wish to perform multiple analyses of the trajectory 
during a simulation.  Obviously, you do not want to overwrite the 
output file from your first analysis when you perform the second analysis of the trajectory.  In addition, you do not want to overwrite
files from earlier runs if you choose to rerun your analysis in a directory where you had already run an earlier calculation.  For these 
reasons whenever you wish to read in the name of an output file you should use the PLMD::analysis::Analysis::parseOutputFile method.  Using this method
ensures that all old files are backed up.  On top of this when you open an output file in your analysis method you should use the following 
set of commands:

\verbatim
OFile gfile; gfile.link(*this);
gfile.setBackupString("analysis");
gfile.fmtField(getOutputFormat()+" ");
gfile.open( ofilename.c_str() ); 
\endverbatim

The second line ensures that files are named analysis.0.ofilename, analysis.1.ofilename and so on.  The third line allows one to set the format
of the output file from the input.

A second point to consider is that it should be possible to restart the process of building a store of data for susbsequent analysis when 
restarting a molecular dynamics simulation.  Once again though this is looked after within the PLMD::Action object.

\section reweight Reweighting trajectories

As discussed in the previous section PLUMED is primarily a code for doing biased molecular dynamics simulations.  This bias is used to force rare events
to occur in the short time scales that are accessible within a molecular dynamics simulation.  Oftentimes when analysing a trajectory we would like 
to remove the contribution of the bias and to reweight the simulation so as to get the underlying free energy surface.  When performing any analysis of 
the trajectory one may similarly wish to remove the effect of the bias and to consider what weight each sampled point would have had if it had been sampled
in accordance with the underlying canonical probability distribution function.  This process of reweighting points - of ascribing a weight to each snapshot
that discounts the effect of the simulation bias - is again looked after within PLMD::analysis::Analysis.  If you wish to take these weights into account in your
analysis method you should use the method PLMD::analysis::Analysis::getWeight to access them.  Obviously, if you have no simulation bias on the system then each 
point will have a weight of one and this will be the weight returned by PLMD::analysis::Analysis::getWeight.  

\section multiple Performing multiple analyses

Obviously, this process of storing all the trajectory frames for later analysis is rather memory intensive.  As such if you wish to perform multiple analyses
on the same segment of trajectory it would be desirable not to store the whole trajectory in memory twice.  To avoid this there are options within PLMD::analysis::Analysis
to reuse the stored trajectory from one analysis object in a second analysis object.  In addition, you can perform a dimensionality reduction analysis on your 
stored trajectory (see \ref dimred) and then do a further analysis (e.g. constructing a histogram or performing a clustering) using the projections of the data
points generated by the dimensionality reduction.  All this functionality is looked after in the PLMD::analysis::Analysis class but if you want to exploit it in your
new analysis method you must use the methods PLMD::analysis::Analysis::getNumberOfDataPoints when you would like to know how many trajectory snapshots were stored, 
PLMD::analysis::Analysis::getReferenceConfiguration when you would like to access one of the stored trajectory snapshots, PLMD::analysis::Analysis::getDataPoint when you want 
to access the values of the arguments in your stored trajectory snapshot and PLMD::analysis::Analysis::getWeight when you wish to access the weight of point.  

\section metrics Calculating distances between snapshots

As discussed in \ref AddingAMetric if you have two snapshots of a trajectory there are many different ways of calculating the distance between them.  You
can measure the displacement of each of the atoms, you can measure the differences between the values a set of collective variables in the two frames or
you can use some combination of these two ideas.  Many analysis algorithms are based on performing analyses of the matrix of 
pairwise distances between different trajectory frames and so we have tried to write plumed in a way that allows users to exploit all these different methods for
calculating the distances between frames in the various analysis algorithms that have been implemented. The benefits of these are twofold:

- If you implement a new analysis method within PLUMED you can compute the matrix of disimilarities in a wide variety of different ways.  You thus have a
very flexible impelementation of your new method.
- If you implement a new way of calculating the disimilarity between two trajectory frames you can imediately use this object in a wide variety of different
ways - analysing the trajectory, paths, etc.   

To calculate the distance between two trajectory snapshots you should use the method PLMD::analysis::Analysis::getDistanceBetweenFrames if you wish to exploit all this 
functionality in your new analysis method.  Please be aware, however, that you should do something slightly different if you are also exploiting landmark
selection functionality (which we would strongly encourage) by inheriting from PLMD::analysis::AnalysisWithLandmarks in your new analysis action. 

\section landmarks Lowering the cost by exploiting landmark selection

Many analyses methods scale poorly with the number of trajectory frames that you wish to analyse.  This happens in part because you need to compute the matrix
of pairwise disimiarities (a square matrix in which the number of columns is equal to the number of trajectory frames) but also because you then have to 
do some algebra involving this matrix.  To alleviate these problems a common strategy is to perform the analysis on a set of so-called landmark frames and to 
then project the non-landmark snapshots from the trajectory using some out-of-sample extension of your analysis algorithm.  Classes that inherit from
PLMD::analysis::AnalysisWithLandmarks are implementations of analysis algorithms that exploit landmark selection in this way.  

There are two ways in which you may wish to extend the set of things plumed can do using landmark selection; namely:

\subsection newland You may wish to implement a new landmark selection algorithm

If you want to implement a new landmark selection algorithm you should write a class that inherits from PLMD::analysis::LandmarkSelectionBase.  Within this 
new class you will need to write a constructor that reads in the input to your method and a method called select that actually does the landmark selection.
Much like the PLMD::Action dynamic polymorphism is exploiting when we call the landmark selection method in PLMD::analysis::AnalysisWithLandmarks so to 
add your new method to the list of landmark selection options you will need to add a command something like this:

\verbatim
PLUMED_REGISTER_LANDMARKS(FarthestPointSampling,"FPS")
\endverbatim

The set of landmarks that you finally select are stored in an object of type PLMD::MultiReferenceBase.  This object can be thought of as an extended 
std::vector<ReferenceConfiguration*> which also includes a weight for each of the landmarks.  These weights are computed in the underlying 
PLMD::analysis::LandmarkSelectionBase and the user can control whether he/she wishes to perform a Voronoi analysis that takes into account 
the weights ascribed to each of the snapshots by the reweighting of the trajectory because of the presence of the bias or not.  All this is once again
looked after in the base class.  All you need to do in your new landmark method is to select the set of landmarks.  Once you are happy with your selection 
these frames can be added to the PLMD::MultiRerferenceBase object using the method PLMD::analysis::LandmarkSelectionBase::selectFrame.

\subsection newmeth You may wish to implement a new analysis algorithm that exploits landmark selection

If you wish to exploit the options for landmark selection in your new analysis method you should write your new analysis class so that it inherits from
PLMD::analysis::AnalysisWithLandmarks.  Furthermore, because you are doing your analysis on a subset of the stored snapshots (the landmark points) you should
be careful when using PLMD::analysis::Analysis::getNumberOfDataPoints, PLMD::analysis::Analysis::getReferenceConfiguration, PLMD::analysis::Analysis::getDataPoint, 
PLMD::analysis::Analysis::getWeight and PLMD::analysis::Analysis::getDistanceBetweenFrames methods as these will return information on the underlying data 
and not on the landmarks.  Furthermore, the method that does the analysis will now be called analyseLandmarks rather than performAnalysis as there is a 
performAnalysis method in PLMD::analysis::AnalysisWithLandmarks that essentially does the landmark selection and then calls the virtual method analyseLandmarks.

There are a number of things that may seem odd within PLMD::analysis::AnalysisWithLandmarks but the thinking when writing this class was to write it 
so that it would be compatible with things that one might wish to do with PLUMED in the future.  As an example the PLMD::MultiReferenceBase object 
in which the landmarks are stored is not created within the constructor of PLMD::analysis::AnalysisWithLandmarks but is rather left to be constructed
in a derived class.  A pointer to this object is then passed back to PLMD::analysis::Analysis using PLMD::analysis::AnalysisWithLandmarks::setDataToAnalyze.
The reason for this is explained in the following two sections.  On top of this there are no methods that are equivalent to the 
PLMD::analysis::Analysis::getNumberOfDataPoints, PLMD::analysis::Analysis::getReferenceConfiguration, PLMD::analysis::Analysis::getDataPoint,
PLMD::analysis::Analysis::getWeight and PLMD::analysis::Analysis::getDistanceBetweenFrames but which return information on the landmarks in the 
PLMD::analysis::AnalysisWithLandmarks abstract base class.  Instead one must extract this information from the PLMD::MultiReferenceBase class
directly using the method PLMD::MultiReferenceBase::getNumberOfReferenceFrames to get the number of landmarks and PLMD::MultiReferenceBase::getFrame 
to return a pointer to a particular landmark frame.

\section dimred Dimensionality reduction

The aim when writing any large code such as PLUMED is to minise the number of lines of code as fewer lines of code means fewer bugs on average.
Hence, as explained in other sections of this developer manual, all the object oriented programming, inheritance and polymorphism.  Given this
consider how we would go about implementing a library of dimensionality reduction algorithms.  In LLE, ISOMAP, sketch-map or MDS the aim is to
generate a low-dimensional projection of some set of high-dimensional data points.  For all these methods we can use the same code to to store 
the high and low dimensional points and to output this data to a file.  In fact the only things that differ in these various different methods are
the ways in which the dissimilarities between the high-dimensional points are calculated and the manner in which the low-dimensional projections
are generated.  We can thus bundle many aspects of the calculation together in an abstract PLMD::analysis::DimensionalityReductionBase class and exploit 
dynamic polymorphism to write methods that calculate the matrix of dissimilarities (PLMD::analysis::DimensionalityReductionBase::calculateAllDistances) 
and the projections (PLMD::analysis::DimensionalityReductionBase::generateProjections).  Furthermore, even within these methods we can exploit 
PLMD::analysis::ClassicalScaling and PLMD::analysis::SMACOF to do much of the work of finding projections as methods such as ISOMAP and MDS differ only 
in the manner in which the dissimilarities between points are calculated - the projections are calculated in the same way in both methods.

The above paragraph is perhaps getting ahead of itself a little.  Lets slow the pace down and consider some of the features of the 
PLMD::analysis::DimensionalityReductionBase abstract base class piece by piece.  The first thing to consider is how this class interacts with
PLMD::PointWiseMapping and what this class actually does.  PLMD::PointWiseMapping inherits from PLMD::MultiReferenceBase so it contains a list of 
trajectory frames and their associated weights.  Furthermore, a pointer to this class can be (and is) passed back to PLMD::analysis::AnalysisWithLandmarks
and used as the object in which the set of landmark configurations are stored.  In addition, to all these features of PLMD::MultiReferenceBase, however,
PLMD::PointWiseMapping must also contain places to store the projections of the high-dimensional configurations and a place to store the matrix of 
pairwise distances between configurations.  You can set the value of a projection of a point using PLMD::PointWiseMapping::setProjectionCoordinate
alternatively you can acess/edit the matrix of pairwise distances using PLMD::PointWiseMapping::modifyDmat.  If you use the methods in 
PLMD::analysis::ClassicalScaling or PLMD::analysis::SMACOF this setting of the projections is looked after for you.

Many dimensionality reduction algorithms have an out-of-sample method that allows one to find the projections of non-landmark points.  
These out-of-sample methods should be incorporated in your new analysis class in the method named PLMD::analysis::DimensionalityReductionBase::getProjectedPoint.
If this is done you can then use the HISTOGRAM method to construct free energy surfaces as a function of you dimensionality reduction coordinates and so on. 

\section cluster Clustering trajectory data

There are currently no clustering methods implemented in the PLMD::analysis module.  This section is thus here to explain how I (Gareth Tribello) imagined one
might go about implementing these methods.  Again there are many commonalities between methods such as kmeans, Gaussian mixture models and so on, which should 
be thought about when constructing an abstract base class.  Furthermore, this abstract base class should (like PLMD::analysis::DimensionalityReductionBase) 
inherit from PLMD::analysis::AnalysisWithLandmarks so as to exploit the use of landmark selection in making the analysis run faster.  One can create an object within this
base class much like PLMD::PointWiseMapping that inherits from PLMD::MultiReferenceBase but that which now contains the functionality to deal with a set of 
clusters rather than projections of each of the trajectory frames.  This object can be used to store the landmarks and also to calculate the weights of each 
of the landmarks that enters in the eStep and mStep of the expectation maximising algorithm.

Obviously, if you are thinking of adding methods to cluster trajectory frames within PLUMED please feel free to get in touch with me (gareth.tribello\@gmail.com).
I will be more than happy to discuss these ideas with you.

*/
